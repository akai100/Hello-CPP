## 1. 深拷贝与浅拷贝
如果一个类包含指针或者资源，使用默认的拷贝构造函数，则可能存在“悬挂指针问题”。像默认的拷贝构造函数这样的拷贝构造方式，称为”浅拷贝“。

## 2. 移动语义

## 3. 左值、右值与右值引用
左值，右值定义：
（1）出现在等号左边的就是“左值”，在等号右边的就是“右值”。
（2）另一个方法：可以取地址的就是、有名字的就是左值。
在C++11中，右值是由两个概念构成的，一个是**将亡值**，另一个是**纯右值**。
**纯右值**：就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。
**将亡值**：C++11新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用T&& 的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

### 3.1 右值引用

右值引用：对一个右值进行引用的类型。可用于延长临时对象的生命周期。由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。例如：
```c++
T&& a = ReturanRvalue();
```
ReturanRvalue返回一个右值，我们声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

## 4. std::move： 强制转化为右值
功能：将一个左值强制转换为右值引用，继而我们可以通过右值引用该值。
被转换的左值，其声明周期没有随着左右值的转化而改变。

## 5. 移动语义的一些其他问题

## 6. 完美转发
完美转发：在函数模板中，完全依照模板的参数的类型。将参数传递给函数模板中调用的另外一个函数。
```c++
template <typename T>
void IamForwording(T t)
{
    IrunCodeActually(t);
}
```
*IamForwording*是一个转发函数模板，对于目标函数*IrunCodeActually*总是希望转发函数将参数按照传入Iamforwarding时的类型传递（即传入IamForwording的是左值对象，IrunCodeActually就能获得左值对象，传入的是右值对象，目标函数就能获得右值对象)。
C++通过引入一条所谓“引用折叠”的新语言规则，并结合新的的模板推到规则来完成完美转发。

```c++
typedef const int T;
typedef T& TR;
TR& v = 1;    // 在C++98中无法通过编译
```
TR& v = 1; 在C++11中，一旦出现了这样的表达式，就会发生引用折叠，

## 7. 引用折叠

引用折叠发生在模板推导或类型别名中出现多重引用时，编译器自动简化引用类型。规则如下：

+ T& &   -> T&  （左值引用）
+ T& &&  -> T&  （左值引用）
+ T&& &  -> T&  （左值引用）
+ T&& && -> T&& （右值引用）

代码实例：
```C++
typedef int&  lref;
typedef int&& rref

lref&  r1 = n;    // int&
lref&& r2 = n;    // int&
rref&  r3 = n;    // int&
rref&& r4 = 1;    // int&&
```
### 7.1 应用

（1）模板既可以接收左值也可以接收右值

模板函数中的 T&& 可同时接收左值和右值，依赖引用折叠实现：

```C++
template<typename T>
void func(T&& t) {    // t 可能是左值或右值引用
}
```
（2）std::forward保持属性
```C++
template<typename T>
void wrapper(T&& arg) {
    target(std::forward<T>(arg));    // 转发时保持左值/右值属性
}
```
## 8. 转发引用

转发引用是一种特殊的引用，它保留了函数参数的值类别，从而可以通过 `std::forward` 将其转发。

（1）
```C++
template<class T>
int g(const T&& x);

template<class T>
int f(T&& x)
{
    return g(std::forward<T>(x));
}
```

## 9. 移动构造函数

移动构造函数被调用通常在```rvalue```或```xvalue```初始化时：

+ 初始化： ```T a = std::move(b);```或者 ```T a(std::move(b))```，其中```b```的类型是T；
+ 函数参数：```f(std::move(a));```
+ 函数返回值：```return a;```,

### 9.1 隐式申明移动构造函数

