## 1. 深拷贝与浅拷贝
如果一个类包含指针或者资源，使用默认的拷贝构造函数，则可能存在“悬挂指针问题”。像默认的拷贝构造函数这样的拷贝构造方式，称为”浅拷贝“。

## 2. 移动语义

## 3. 左值、右值与右值引用
左值，右值定义：
（1）出现在等号左边的就是“左值”，在等号右边的就是“右值”。
（2）另一个方法：可以取地址的就是、有名字的就是左值。
在C++11中，右值是由两个概念构成的，一个是**将亡值**，另一个是**纯右值**。
**纯右值**：就是C++98标准中右值的概念，讲的是用于辨识临时变量和一些不跟对象关联的值。
**将亡值**：C++11新增的跟右值引用相关的表达式，通常是将要被移动的对象（移为他用），比如返回右值引用T&& 的函数返回值、std::move的返回值、或者转换为T&&的类型转换函数的返回值。

右值引用：对一个右值进行引用的类型。由于右值通常不具有名字，我们只能通过引用的方式找到它的存在。例如：
```c++
T&& a = ReturanRvalue();
```
ReturanRvalue返回一个右值，我们声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

## 4. std::move： 强制转化为右值
功能：将一个左值强制转换为右值引用，继而我们可以通过右值引用该值。
被转换的左值，其声明周期没有随着左右值的转化而改变。

## 5. 移动语义的一些其他问题

## 6. 完美转发
完美转发：在函数模板中，完全依照模板的参数的类型。将参数传递给函数模板中调用的另外一个函数。
```c++
template <typename T>
void IamForwording(T t)
{
    IrunCodeActually(t);
}
```
*IamForwording*是一个转发函数模板，对于目标函数*IrunCodeActually*总是希望转发函数将参数按照传入Iamforwarding时的类型传递（即传入IamForwording的是左值对象，IrunCodeActually就能获得左值对象，传入的是右值对象，目标函数就能获得右值对象)。
C++通过引入一条所谓“引用折叠”的新语言规则，并结合新的的模板推到规则来完成完美转发。

```c++
typedef const int T;
typedef T& TR;
TR& v = 1;    // 在C++98中无法通过编译
```
TR& v = 1; 在C++11中，一旦出现了这样的表达式，就会发生引用折叠，
