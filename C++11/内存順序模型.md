# 内存順序模型

## 原理

### 指令乱序

现在的CPU都采用的是多核、多线程技术用以提升计算能力；采用乱序执行、流水线、分支预测以及多级缓存等方法来提升程序性能。
多核技术在提升程序性能。多核技术在提升程序性能的同时，也带来了执行序列乱序和内存序列访问的乱序问题。与此同时，编译器
也会基于自己的规则对代码进行优化，这些优化动作也会导致一些代码的顺序被重排。

C++11引入Memory model的意义在于有了一个语言层面的、与运行平台和编译器无关的标准库，可以使得开发人员更为便捷高效地控制内存访问顺序。

引入内存模型的原因：

+ 编译器优化：在某些情况下，即使是简单的语句，也不能保证是原子操作
+ CPU out-of-order：CPU为了提升计算性能，可能会调整指令的执行顺序
+ CPU Cache不一致：在CPU Cache的影响下，在某个CPU下执行了指令，不会立即被其它CPU所看到

### 关系术语

#### sequenced-before

sequenced-before是一种单线程上的关系，这是一个非对称，可传递的成对关系。

sequenced-before就是对在同一个线程内，求值顺序关系的描述：
+ 如果A sequenced-before B，代表A的求值会先完成，才进行对B的求值；
+ 如果A not sequenced-before B，而B sequenced-before A，则代表先对B进行求值，然后对A进行求值；
+ 如果A not sequenced-before B，而B not sequenced-before A，则A和B都有可能先执行，甚至可以同时执行；

#### happens-before

happens-before是sequenced-before的扩展，因为它还包含了不同线程之间的关系。当A操作happens-before B操作的时候，
操作A先于操作B执行，且A操作的结果对B来说可见。

happens-before包含两种情况，一种是同一线程内的happens-before关系(等同于sequenced-before)，另一种是不同线程的happens-before关系。

C++中定义了5种能够建立跨线程的happens-before的场景，如下：

+ A synchronizes-with B
+ A is dependency-ordered before B
+ A synchronizes-with some evaluation X，and X is sequenced-before B
+ A is sequenced-before some evaluation X，and X inter-thread happens-before B
+ A inter-thread happens-before some evaluation X， and X inter-thread happens-before B

##### synchronizes-with

synchronized-with描述的是不同线程间的同步关系，当线程A synchronized-with线程B的时，代表线程A对某个变量或者内存的操作，对于线程B是可见的。

换句话说：“synchronized-with就是跨线程版本的happens-before”

synchronizes-with是这样一种关系，它可以保证线程A的写操作结果，在线程B是可见的。

C++提供的同步操作，也就是使用atomic或mutex。


### memory_order

C++11中引入了六种内存约束符用以解决多线程下的内存一致性问题：

```c++
typedef enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
} memory_order;
```

这六种内存约束符从读/写的角度进行划分的话，可以分为以下三种：
+ 读操作（memory_order_acquire memory_order_consume）
+ 写操作（memory_order_release）
+ 读-修改-写操作（memory_order_acq_rel memory_order_seq_cst）

从访问控制的角度可以分为以下三种：
+ Sequential consistency模型（memory_order_seq_cst）
+ Relax模型（memory_order_relaxed）
+ Acquire-Release模型（memory_order_consume memory_order_acquire memory_order_release memory_order_acq_rel）

### 内存模型

#### Sequential consistency 模型

Sequential consistency 模型又称为顺序一致性模型，是控制粒度最严格的内存模型。

在顺序一致性模型下，程序的执行顺序与代码顺序严格一致，也就是说，在顺序一致性模型中，不存在指令乱序。

顺序一致性模型对应的约束符号是memory_order_seq_cst，这个模型对于内存访问顺序的一致性控制是最强的，

#### Relax 模型

Relax模型对应的是memory_order中的memory_order_relaxed。从其字面意思就能看出，其对于内存序的限制最小，
也就是说这种方式只能保证当前的数据访问是原子操作（不会被其他线程的操作打断），但是对内存访问顺序没有任何
约束，也就是说对不同的数据的读写可能会被重新排序。

#### Acquire-Release 模型

Acquire-Release模型的控制力度介于Relax模型和Sequential consistency模型之间。其定义如下：

+ Acquire: 如果一个操作X带有acquire语义，那么在操作X后的所有读写指令都不会被重排序到操作X之前。
+ Release：如果一个操作X带有release语义，那么在操作X前的所有读写指令操作都不会被重排序到操作X之后。

##### memory_order_release
##### memory_order_acquire
##### memory_order_consume
##### memory_order_acq_rel


