# 多线程内存模型

C++11 之前，C++ 标准完全不涉及多线程，线程运行依赖平台（如 POSIX Threads、Windows 线程），导致多线程代码无法跨平台且存在隐蔽的内存竞争问题。
C++11 首次引入**标准化多线程内存模型**，核心目标是：定义多线程访问共享内存时的**可见性**、**原子性**、**有序性**规则，让跨平台多线程编程有统一标准，同时允许
编译器和硬件进行合理优化（不牺牲性能）。

## 3规则

### 原子性

1. 定义

一个操作要么完全执行，要么完全不执行，中间不会被其他线程打断（不可分割）。

2. 解决方案

C++11 原子性解决方案，封装原子操作，无需手动加锁。

### 可见性

1. 定义

一个线程对共享变量的修改，能被其他线程“及时看到”。

2. 问题场景

CPU 缓存（寄存器、L1/L2 缓存）和编译器优化可能导致“修改不可见” —— 线程A 修改了变量x，但修改仍停留在 A 的CPU缓存中，未同步到主存，线程B读取 x 时从主存/自己的缓存获取旧值。

3. 解决方案

原子操作、内存屏障（```std::memory_order```）、互斥锁（```std::mutex```），强制缓存同步

### 有序性

1. 定义

线程内的指令执行顺序，以及跨线程指令的可见顺序，符合程序预期。

2. 问题场景

编译器优化（指令重排）和 CPU 乱序执行（为提升性能，在不影响单线程语义的前提下调整指令顺序），可能导致多线程指令顺序与代码顺序不一致。

3. 解决方案

通过```std::memory_order```定义内存序，限制指令重排和缓存同步规则。

## std::memory_order

C++11 原子操作的行为由```std::memory_order```控制，它既限定了**指令重排的限制**，也规定了**缓存同步的规则**。

### 常用内存序

1. ```memory_order_seq_cst```（顺序一致性，默认）
+ 最严格的内存序，保证：
  
  (1) 线程内指令按代码顺序执行（无重排）；
  
  (2) 所有线程看到的原子操作顺序完全一致（全局统一顺序）；

+ 特点：简单直观（符合单线程思维），但性能开销最大（可能禁用编译器/CPU优化，强制缓存强同步）
+ 使用场景：对顺序要求严格、且性能不敏感的场景（如简单计数器、状态标记）；
  
2. ```memory_order_acquire```（获取）
+ 仅用于读操作（load），规则：
  
  （1）禁止当前线程中，acquire 之后的指令重排到 acquire 之前；

  （2）其他线程对同一原子变量的 release 写操作，其修改对当前线程可见；

+ 核心：“获取”其他线程释放的修改，建立“线程间 happers-before 关系”

3. ```memory_order_release```（释放）

+ 仅用于写操作（store），规则：

  （1）








