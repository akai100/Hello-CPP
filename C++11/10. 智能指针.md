# unique_ptr
## 简介
  无法与其他```unique_ptr```共享所值对象的内存。
```C++
unique_ptr<int> up1(new int(11))
unique_ptr<int> up2 = up1;    // 无法通过编译
```
删除了左值赋值和左值赋值构造函数。

## 实现
### 构造函数


# shared_ptr
## shared_ptr 介绍
  ```shared_ptr```通过指针保持对象共享所有权的智能指针。多个```shared_ptr```对象可占有同一对象。
  
  在下面两种情况下销毁对象并释放其内存：
  
  （1）最后剩下的占用对象的```shared_ptr```被销毁；
  
  （2）最后剩下的占有对象的```shared_ptr```被通过```operator=```或```reset()```赋值为另一指针。
## 成员和函数
### 构造函数
```C++
std::shared_ptr<int> sp1();         // 默认构造函数，构造无被管理对象的 shared_ptr，即空 shared_ptr
std::shared_ptr<int> sp2(nullptr);  // 同上

// 构造 shared_ptr，管理 ptr 所指向的对象
std::shared_ptr<int> sp3(new int(10));

```
## 其他

### std::enable_shared_from_this

```std::enable_shared_from_this```能让其一个对象（假设其名为 t，且已被一个```std::shared_ptr```对象 pt 管理）安全的生成其他额外的```std::shared_ptr```实例（假设名为 pt1, pt2，...），它们与pt共享 t 的所有权。

```c++
struct Good : std::enable_shared_from_this<Good>
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};

struct Bad
{
    std::shared_ptr<Bad> getptr() {
        return std::shared_ptr<Bad>(this);
    }
};

int main()
{
    std::shared_ptr<Good> sp1 = std::make_shared<Good>();
    std::shared_ptr<Good> sp2 = sp1->getptr();    // sp1 和 sp2 共享同一个对象

    try {
        Good not_so_good;
        std::shared_ptr<Good> sp3 = not_so_good.getptr()l
    } catch (std::bad_weak_ptr& e) {
        // c++17 前未定义行为，C++17  起跑出 std::bad_weak_ptr 异常
        std::cout << e.what() << std::endl;
    }

    std::shared_ptr<Bad> bp1 = std::make_shared<Bad>();
    std::shared_ptr<Bad> bp2 = bp1->getptr()
    // Bad 对象将被会析构两次
    return 0;
}
```



# weak_ptr

## 应用场景
### 解决循环引用问题
```C++
struct A;
stuct B {
    std::weak_ptr<A> a_ptr;
    ~B() { std::count << "B 销毁\n"; }
};
struct A {
    std::shared_ptr<B> b_ptr;
    ~A() { std::cout << "A 销毁\n"; }
};
```
当 A 和 B 相互引用时，通过weak_ptr可避免内存泄漏。

在图结构和双向链表，节点间互斥```shared_ptr```会导致循环引用，通过```weak_ptr``作为反向指针可确保资源释放。

### 观察者模式

问题： 主题（Subject）需要持有观察者（Observer）的引用，但不能控制其生命周期（否则可能会延长对象存活时间）。

```C++
class Subject {
    std::vector<std::weak_ptr<Observer>> observers_;
public:
    void notify() {
        for (auto& wp = observers_) {
            if (auto sp = wp.lock()) {
                sp->update();
            }
        }
    }
};
```

### 缓存系统

问题：缓存需要管理资源但不应阻止资源释放。

### 跨模块/线程安全访问

解决问题：在异步任务或跨线程场景中，通过```weak_ptr``安全检测目标对象是否存活

```C++
auto sp = std::make_shared<Object>();

std::weak_ptr<Object> wp(sp);
if (auto shared = wp.lock()) {
    shared->doSomething();
}
```

### 扩展应用场景

解决问题：通过别名构造器创建指向成员对象的```weak_ptr```，确保成员生命周期不超越父对象。

```C++
struct Parent { int data };
auto parent = std::make_shared<Parent>();
std::weak_ptr<int> data_ref(parent, &parent->data);
```



