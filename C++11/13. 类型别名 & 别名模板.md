# 类型别名

+ 功能

类型别名（Type Aliases）为现有类型创建新名称，不引入新类型，仅作为语法糖。

+ 语法
```C++
using NewName = ExistingType;    // C++11 推荐
typedef ExistingType OldName;    // C++98 传统方式
```

+ 优势

（1）声明直观（类似于变量赋值）

（2）支持函数指针等复杂类型的清晰定义；
```C++
using FuncPtr = int(*)(int, int);    // 优于 typedef int(*FuncPtr)(int, int);
```

# 别名模板

+ 功能

别名模板（Alias Templates）为模板创建别名，支持泛型编程。

+ 语法

```C++
template <typename T>
using Vec = std::vector<T>;
```

+ 特化限制&解决方案

别名模板不能直接特化或偏特化，因其本质是类型别名而非独立模板实体。但是可以通过以下方法模拟特化效果：

（1）特化底层类模板

定义辅助模板 remove_reference，通过其内部 type 成员实现特化逻辑。

```C++
template <typename T> struct remove_reference { using type = T; }
template <typename T> struct remove_reference { using type = T; }
template <typename T>
using remove_reference_t = typename remvoe_reference<T>::type;
```
（2）使用编译期条件判断

结合 std::conditional_t 结合类型特性选择目标类型：

```C++
template <typename T>
using SafePtr = std::conditional_t<std::is_pointer_v<T>, std::shared_ptr<T>, T>;
```


