# 1. 共享数据带来的问题

## 1.1 条件竞争

## 1.2 避免恶性条件竞争

# 2. 使用互斥量保护共享数据

## 2.1 C++ 中使用互斥量

C++ 通过实例化```std::mutex```创建互斥量，通过成员函数```lock()```进行上锁，```unlock()```进行解锁。
不过不推荐直接调用成员函数，因为需要在每个函数出口都要调用```unlock()```接口，也包括异常情况。

C++标准库为互斥量提供了一个 RAII 语法的模板类```std::lock_guard···，在构造的时候提供锁的互斥量，并在析构的时候进行解锁。

```C++
std::mutx some_mutex;
std::lock_guard<std::mutex> guard(some_mutex)
```

## 2.2 精心组织代码来保护共享数据

切勿将受保护的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。

## 2.3 发现接口内在的条件竞争



## 2.4 死锁：问题描述及解决方案

## 2.5 避免死锁的进阶指导

+ 避免嵌套锁
+ 避免在持有锁时调用用户提供的代码
+ 使用固定顺序来获取锁
+ 使用锁的层次结构

## 2.6 std::unique_lock —— 灵活的锁

```std::unique_lock``` 使用更为自由的不变量，这样```std::unique_lock```示例不会总与互斥量的数据类型相关，使用起来要比```std::lock_guard```更加灵活。

通过第二个参数，我们可以对互斥量进管理：

（1）```std::defer_lock```

表明互斥量应保持解锁状态

（2）

## 2.7 不同域中互斥量所有权的转移

## 2.8 锁的粒度

# 3. 保护共享数据的替代设施

## 3.1 保护共享数据的初始化过程

使用```std::call_once```作为类成员的延迟初始化（线程安全）
```C++
std::once_flag resource_flag;

void init_resource()
{
    resource_ptr.reset(new some_resource);
}

void foo()
{
    std::call_once(resource_flag, init_resource);
    resource_ptr->do_something();
}
```

## 3.2 保护很少更新的数据结构

## 3.3 嵌套锁

嵌套锁：```std::recursive_mutex```







