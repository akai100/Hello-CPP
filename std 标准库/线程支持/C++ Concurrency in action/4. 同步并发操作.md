# 1. 等待一个事件或其他条件

一个线程等待另一个线程完成任务：

（1）持续检查共享数据标志

（2）等待线程在检查间隙，使用```std::this_thread::sleep_for()```进行周期性检查；

（3）条件变量

## 1.1 等待条件达成

C++ 标准库实现：```std::condition_variable```和```std::condition_variable_any``` 两套实现。

两者都需要与一个互斥量一起才能工作（互斥量是为了同步），前者仅限与```std::mutex```一起工作，而后者
可以和任何满足最低标准的互斥量一起工作。

```C++
std::mutex mut;
std::queue<data_chunk> data_queue;
std::condition_variable data_cond;

void data_preparation_thread()
{
    while (more_data_to_prepare()) {
        data_chunk const data = prepare_data();
        std::lock_guard<std::mutex> lk(mut);
        data_queue.push(data);
        data_cond.notify_one();
    }
}

void data_processing_thread()
{
    while (ture) {
        std::unique_lock<std::mutex> lk(mut);
        // 如果条件满足（lambda 函数返回true）时返回；
        // 如果条件不满足（lambda 函数返回 false）: (1) wait 函数将解锁互斥量，并且将这个线程置于阻塞或等待状态；
        // 当其他线程调用 notify_one() 通知条件变量时，处理数据的线程从睡眠中苏醒，重新获取互斥锁。
        data_cond.wait(lk, []{ return !data_queue.empty(); });
        data_chunk data = data_queue.front();
        data_queue.pop();
        lk.unlock();
        process(data);
    }
}
```

## 1.2 使用条件变量构建线程安全队列

```c++
std::mutex mut;
std::queue<data_chunk> data_queue;
std::condition
```

## 2. 使用期望等待一次性事件

C++ 标准库模型将一次性事件称为 “期望”，并支持两种期望：

1. 唯一期望（unique futures，std::future<>）

    只能与一个指定事件相关联，

共享期望（shared futures，std::shared_future<>）

    可以关联多个事件。

## 2.1 带返回值的后台任务

```std::async```启动一个异步任务，与 ```std::thread``` 对象等待运行方式的不同，```std::async``` 会返回一个 ```std::future``` 对象，
这个对象持有最终计算出来的结果。当你需要这个值时，你只需要调用这个对象的get()成员函数；并且直到“期望”状态为就绪的情况下，线程才会阻塞；之后，返回计算结
果。

1. 简单
   
```C++
int find_the_answer_to_ltuae();

std::future<int> the_answer = std::async(find_the_answer_to_ltuae);
do_other_stuff();
std::cout << "The answer is " << the_answer.get() << std::endl;
```

2. 传递参数

```C++
struct X
{
    void foo(int, std::string const &);
    std::string bar(std::string const &);
};

X x;
auto f1 = std::async(&X::foo, &x, 32, "hello");
auto f2 = std::async(&X::bar, x, "goodbyte");


```

## 2.2 任务与期望

```std::packaged_task``` 对一个函数或可调用对象，绑定一个期望，当```std::packaged_task```对象被调用，它就会调用相关函数或可调用对象，将期望状态置为就绪，
返回值也会被存储为相关数据。

## 2.3 使用 std::promises

## 2.4 为期望存储异常

# 3. 限定等待事件

## 3.1 时钟

## 3.2 时延

## 3.3 时间点

## 3.4 具有超时功能的函数


# 4. 使用同步操作简化代码

## 4.1 使用 “期望” 的函数化编程

## 4.2 使用消息传递的同步操作







